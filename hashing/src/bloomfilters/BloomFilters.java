package bloomfilters;

/*
What is Bloom Filter?

A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set.

Suppose you are creating an account on Geekbook, you want to enter a cool username, you entered it and got a message, “Username is already taken”. You added your birth date
along username, still no luck. Now you have added your university roll number also, still got “Username is already taken”.
But have you ever thought how quickly Geekbook check availability of username by searching millions of username registered with it. There are many ways to do this job –

Linear search : Bad idea!

Binary Search : Store all username in sorted order and perform a binary search.This technique is better but still it requires multiple steps.

Bloom Filter is a data structure that can do this job.The price we pay for efficiency is that it is probabilistic in nature that means, there might be some False Positive results.
False positive means, it might tell that given username is already taken but actually it’s not.

Interesting Properties of Bloom Filters
Unlike a standard hash table, a Bloom filter of a fixed size can represent a set with an arbitrarily large number of elements.

Adding an element never fails. However, the false positive rate increases steadily as elements are added until all bits in the filter are set to 1,
at which point all queries yield a positive result..

Bloom filters never generate false negative result, i.e., telling you that a username doesn’t exist when it actually exists.

Deleting elements from filter is not possible because, if we delete a single element by clearing bits at indices generated by k hash functions,
it might cause deletion of few other elements. Example – if we delete “geeks” (in given example below) by clearing bit at 1, 4 and 7, we might end up deleting “nerd” also
Because bit at index 4 becomes 0 and bloom filter claims that “nerd” is not present.


Working of Bloom Filter

A empty bloom filter is a bit array of m bits, all set to zero, like this –

0 1 2 3 4 5 6 7 8 9 -- index
0 0 0 0 0 0 0 0 0 0 -- all elements set as 0

We need k number of hash functions to calculate the hashes for a given input. When we want to add an item in the filter, the bits at k indices h1(x), h2(x), … hk(x) are set,
where indices are calculated using hash functions.
Example – Suppose we want to enter “geeks” in the filter, we are using 3 hash functions and a bit array of length 10, all set to 0 initially. First we’ll calculate the hashes as
following :

h1(“geeks”) % 10 = 1
h2(“geeks”) % 10 = 4
h3(“geeks”) % 10 = 7

Note: These outputs are random for explanation only.
Now we will set the bits at indices 1, 4 and 7 to 1
0 1 2 3 4 5 6 7 8 9 -- index
0 1 0 0 1 0 0 1 0 0

Again we want to enter “nerd”, similarly we’ll calculate hashes

h1(“nerd”) % 10 = 3
h2(“nerd”) % 10 = 5
h3(“nerd”) % 10 = 4

Set the bits at indices 3, 5 and 4 to 1
0 1 2 3 4 5 6 7 8 9 -- index
0 1 0 1 1 1 0 1 0 0

Now if we want to check “geeks” is present in filter or not. We’ll do the same process but this time in reverse order. We calculate respective hashes using h1, h2 and h3 and
check if all these indices are set to 1 in the bit array. If all the bits are set then we can say that “geeks” is probably present. If any of the bit at these indices are 0
then “geeks” is definitely not present.

False Positive in Bloom Filters
The question is why we said “probably present”, why this uncertainty. Let’s understand this with an example. Suppose we want to check whether “cat” is present or not.
We’ll calculate hashes using h1, h2 and h3

h1(“cat”) % 10 = 1
h2(“cat”) % 10 = 3
h3(“cat”) % 10 = 7

If we check the bit array, bits at these indices are set to 1 but we know that “cat” was never added to the filter. Bit at index 1 and 7 was set when we added “geeks” and bit 3 was
set we added “nerd”.

So, because bits at calculated indices are already set by some other item, bloom filter erroneously claim that “cat” is present and generating a false positive result.
Depending on the application, it could be huge downside or relatively okay.

We can control the probability of getting a false positive by controlling the size of the Bloom filter. More space means fewer false positives. If we want decrease probability of
false positive result, we have to use more number of hash functions and larger bit array. This would add latency in addition of item and checking membership.


Space Efficiency

If we want to store large list of items in a set for purpose of set membership, we can store it in hashmap, tries or simple array or linked list. All these methods require
storing item itself, which is not very memory efficient. For example, if we want to store “geeks” in hashmap we have to store actual string “ geeks” as a key value pair
{some_key : ”geeks”}.

Bloom filters do not store the data item at all. As we have seen they use bit array which allow hash collision. Without hash collision, it would not be compact.

Choice of Hash Function

The hash function used in bloom filters should be independent and uniformly distributed. They should be fast as possible. Fast simple non cryptographic hashes which are independent
enough include murmur, FNV series of hash functions and Jenkins hashes.
Generating hash is major operation in bloom filters. Cryptographic hash functions provide stability and guarantee but are expensive in calculation. With increase in number of
hash functions k, bloom filter become slow. All though non-cryptographic hash functions do not provide guarantee but provide major performance improvement.

Applications of Bloom filters

Medium uses bloom filters for recommending post to users by filtering post which have been seen by user.
Quora implemented a shared bloom filter in the feed backend to filter out stories that people have seen before.
The Google Chrome web browser used to use a Bloom filter to identify malicious URLs
Google BigTable, Apache HBase and Apache Cassandra, and Postgresql use Bloom filters to reduce the disk lookups for non-existent rows or columns



 */

public class BloomFilters {
}